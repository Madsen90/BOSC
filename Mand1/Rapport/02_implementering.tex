\section{Implementering}
\subsection{Uafh\ængighed}
Vi benytter os ikke af andre shells i vores shell, og anser derfor vores program som værende uafhængigt. 

\subsection{Hostname}
For at udskrive hostnavnet i kommando-prompt'en, har vi \åbnet filen "/proc/sys/kernel/Hostname" med fopen. Derefter l\æser vi f\ørste linje i filen ind i en buffer med fgets, og scanner linjen ind i vores hostname variabel med sscan. Til sidst lukker vi filen med fclose. Der er ikke noget fejlh\åndtering på om filen indeholder noget, eller om den overhovedet eksisterer, med den begrundelse at vi initialiserer vores hostname variabel med strengen "DEFAULT", og derefter overskriver denne variabel, hvis altså filen eksisterer og indeholder tekst. Hvis ikke, bliver variablen ikke overskrevet, og shell'en vil altså udksrive "DEFAULT".

\subsection{Kommando håndtering}

\subsection{Baggrundskørsel af kommandoer}

\subsection{Redirection}

\subsection{Piping}

\subsection{Exit kommando}

\subsection{ctrl+c}
Vi fanger ctrl+c gennem kommandoen "signal(SIGINT, interruptRun);". Denne fanger ethvert ctrl+c og, i stedet for at interrupte bosh-kørselen, kaldes "void interruptRun(int dummy)" metoden. interrruptRun udskriver blot "caught ctrl+c" og fortsætter herefter kørslen af programmet. Grunden til at vi ikke sender interruptet videre ned i evt. kørende programmer, er at disse samtidig vil fange det samme ctrl+c input og terminere. Altså er der ikke behov at vi aktivt terminerer dem. Det skal dog også nævnes at dette ikke vil terminere evt. baggrundsprocesser, da disse ikke vil fange ctrl+c inputtet, men da vi har modelleret vores shell efter linux's indbyggede terminal, og denne har samme opførsel, så antager vi at dette er acceptabelt. 

