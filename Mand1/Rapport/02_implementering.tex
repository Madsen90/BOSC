\section{Implementering}

\subsection{Hostname}
For at udskrive hostnavnet i kommando-prompt'en, har vi åbnet filen "/proc/sys/kernel/Hostname" med fopen. Derefter læser vi første linje i filen ind i en buffer med fgets, og scanner linjen ind i vores hostname variabel med sscan. Til sidst lukker vi filen med fclose. Der er ikke noget fejlhåndtering på om filen indeholder noget, eller om den overhovedet eksisterer, med den begrundelse at vi initialiserer vores hostname variabel med strengen "DEFAULT", og derefter overskriver denne variabel, hvis altså filen eksisterer og indeholder tekst. Hvis ikke, bliver variablen ikke overskrevet, og shell'en vil altså udksrive "DEFAULT".

\subsection{Kommando håndtering}

\subsection{Baggrundskørsel og forgrundskørsel af kommandoer}


\subsection{Piping og redirection}
Redirection og piping er blevet implementeret i samme kode, da det stort set er samme funktionalitet.
Der oprettes der en pipe, hver gang en kommando k1 skal sende sit output til k2, oprettes der en pipe hvis skriveende gives som k1's input fil og læse end gives til k2's læseende. Input- og output redirection kan således ses som en halv pipe, som gives til henholdvis den første og sidste kommando der skal eksekveres. Det sker ved at filerne åbnes i hovedprocessen, og deres filedescriptors kan herefter bruges på samme måde som pipe-ender. Løbende lukker hovedprocessen for filer og pipe-ender, som fremover ikke vil skulle bruges af kommandoer.

\vspace{1cm}
\includegraphics[scale=0.75, trim= 2cm 0cm 0cm 0cm]{pipefig}

\vspace{1cm}


Vi nåede frem til, at det gav bedst mening at kommandoerne blev udført i den rækkefølge som resultaterne skulle bruges i.
Med andre ord, hvis kommando k1's output skal pipes til kommando k2's input, så skal kommando k1 udføres før kommando k2.
Hovedårsagen til dette valg var, at det gjorde det nemt at køre en kommando-række enten som en række forgrundsprocesser eller baggrundsprocesser, da kommandoerne bare kan udføres sekventielt, uden at bekymre sig om der ventes på en forgrundsproces. For at kunne have samtidig kørsel af kommandoer der undervejs generere output der pipes til hinanden, så køres kun den sidste kommando som forgrundsproces. Det har medført, at hvis den sidste kommando terminere før de forudgående baggrundsprocesser, kan et ske at baggrundsprocesser efterlades kørende, hvilket vi er nået frem til er årsagen til må være årsagen til at listen oprindeligt vendte som den gjorde. Disse baggrundsprocesser er dog ikke synlige for brugeren, men det er muligivis stadigvæk problematisk, hvis en af de efterladte baggrundsprocessor fylder en skrive-enden af en pipe kan der opstå et deadlock, men det må også kunne ske, ved eksekvering i den omvendte rækkefølge.

\subsection{Exit kommando}
 
\subsection{ctrl+c}
Vi fanger ctrl+c gennem kommandoen "signal(SIGINT, interruptRun);". Denne fanger ethvert ctrl+c og, i stedet for at interrupte bosh-kørselen, kaldes "void interruptRun(int dummy)" metoden. interrruptRun udskriver blot "caught ctrl+c" og fortsætter herefter kørslen af programmet. Grunden til at vi ikke sender interruptet videre ned i evt. kørende programmer, er at disse samtidig vil fange det samme ctrl+c input og terminere. Altså er der ikke behov at vi aktivt terminerer dem. Det skal dog også nævnes at dette ikke vil terminere evt. baggrundsprocesser, da disse ikke vil fange ctrl+c inputtet, men da vi har modelleret vores shell efter linux's indbyggede terminal, og denne har samme opførsel, så antager vi at dette er acceptabelt. 

