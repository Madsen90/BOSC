\section{Implementation}
I dette afsnit vil vi gå lidt mere i dybden med hvordan vi har implementeret vores løsninger som omtalt i afsnit \ref{sec:design} om design.

\subsection{Page fault handler}
Page handleren er den metode, der bliver kaldt, når vi får en page fault. Første bliver der checket, om page fault'en er en write request, hvilket ville gøre sideskiftning unødvændig, da vi i dette tilfælde bare ville sætte skrive rettighederne på den pågældende page.

Sidenhen checkes der, om der er nogen fri frame, ved at gennemløbe vores frametable (map). Her chekkes der om der er nogen side, der aldrig har været brugt; at den i frametable er -1.\footnote{Her kunne en optimering være ikke at gennemløbe map'et, efter at der ikke var nogle "uinitialiserede" fysiske sider, eftersom de aldrig ville blive "uinitialiserede" igen}

Hvis der ikke er nogen "uinitialiseret" frame, kommer frameSelecter i brug, og den bruger en af sideskiftning algoritmerne til at finde den optimale frame at skifte ud. Data på den frame bliver skrevet til disken, og den pågældende frame sættes til at være fri. Så opdateres vores frametable og sætter indexet på den frie side til at være den side, der har fremprovokeret en page fault.

Derefter læses det ønskede data ind fra disken til den nu fundne freeframe.

\subsection{Sideskrifnings algoritmer}
Der er implementeret tre sideskiftnings algoritmer. Deres implementation bliver kort beskrevet nedenfor.

\subsubsection{Rand}
Rand algoritmen sætter bare pointeren til den frie fysiske side til et vilkårligt tal fra 0-N, hvor N er tallet af fysiske sider. Funktionen srand48 bliver brugt til seeding og lrand48 bliver brugt til at generere tal.

\subsection{FIFO}
FIFO algoritmen virker som en FIFO kø. Hvis ingen fysisk side er tilgængelig og en side skal skiftes ud, så skifter algoritmen den først brugte side ud med en ny.

Det gøres ved at opretholde datastrukturen FIFOData, der rent faktisk kun består af et heltal. Det heltal bliver incrementeret hver gang der er brug for en side indtil vi rammer tallet npages, tallet af fysiske sider, så starter vi fra 0, den første side, igen ved hjælp af modulo operatoren.

\subsection{Custom}
Det gøres ved at opretholde datastrukturen FIFOData, der rent faktisk kun består af et heltal. Det heltal bliver incrementeret hver gang der er brug for en side indtil vi rammer tallet npages, tallet af fysiske sider, så starter vi fra 0, den første side, igen ved hjælp af modulo operatoren. Implementationen virker under den antagelse at sider aldrig frigives og at frie frames uddelles i rækkefølge.

\subsection{Custom}
Custom algoritmen er en version af en tilnærmet "Last recently used"-algoritme (LRU). For at kunne få et billede af hvornår en side sidst har læst eller skrevet til hukommelsen, så fjernes alle siders skriverettigheder med et fast interval. Alle sider der nu enten vil skrive eller læse fra hukommelsen vil nu blive fanget i page\_fault\_handleren(). Her registreres det, at siden er blevet tilgået indenfor denne periode. For at undgå at disse fremprovokerede faults ikke ender i flere disk tilgange holdes der styr på, om hvorvidt en pågældende side allerede er mappet til den fysiske hukkomelse.
Hver side i den virtuelle hukkomelse bliver tildelt to heltal som bruges til at holde styr på hvornår siden sidst er blevet tilgået, dens historie, og hvilke rettigheder siden havde sidst den havde adgang til den fysiske hukommelse. Historikken bliver brugt som beskrevet i "Operating System Concepts", side 410. Hvis flere sider har samme laveste historik, så vælges den som er koblet til den laveste frame. Det betyder at en fifo-struktur ved samme historik ikke er garanteret. Det kunne være løst ved at bruge en hægtet liste som historik.